%要运行该模板，LaTex需要安装CJK库以支持汉字.
%字体大小为12像素，文档类型为article
%如果你要写论文，就用report代替article
%所有LaTex文档开头必须使用这句话
\documentclass[12pt]{article}

%使用支持汉字的CJK包
\usepackage{url}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{CJK}
\usepackage{algorithm}
\usepackage{soul}
\usepackage{algorithmic}
\usepackage{enumerate}
%开始CJK环境,只有在这句话之后,你才能使用汉字
%另外,如果在Linux下,请将文件的编码格式设置成GBK
%否则会显示乱码
\begin{CJK*}{GBK}{song}
\usepackage{xcolor}
%这是文章的标题
\title{模块初始化框架}

%这是文章的作者
\author{赵庶林}

%这是文章的时间
%如果没有这行将显示当前时间
%如果不想显示时间则使用 \date{}
%\date{2008/10/12}

%以上部分叫做"导言区",下面才开始写正文





\begin{document}
%先插入标题
\maketitle
%再插入目录
\tableofcontents
%以下是定义C语言的格式
\lstset{ %Settings for listings package.
language=[ANSI]{C},
backgroundcolor=\color{lightgray},
basicstyle=\footnotesize,
breakatwhitespace=false,
breaklines=true,
captionpos=b,
commentstyle=\color{olive},
directivestyle=\color{blue},
extendedchars=false,
% frame=single,%shadowbox
framerule=0pt,
keywordstyle=\color{blue}\bfseries,
commentstyle=\color{red!50!green!50!blue!50},
frame=shadowbox,
rulesepcolor=\color{red!20!green!20!blue!20},
morekeywords={*,define,*,include...},
numbersep=5pt,
rulesepcolor=\color{red!20!green!20!blue!20},
showspaces=false,
showstringspaces=false,
showtabs=false,
stepnumber=1,
stringstyle=\color{purple},
tabsize=4,
title=\lstname,
numbers=left, numberstyle=\tiny,
escapeinside=``
}

%以下一行是定义插入网址的断行定义：
\def\UrlBreaks{\do\A\do\B\do\C\do\D\do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N\do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X\do\Y\do\Z\do\[\do\\\do\]\do\^\do\_\do\`\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w\do\x\do\y\do\z\do\0\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\.\do\@\do\\\do\/\do\!\do\_\do\|\do\;\do\>\do\]\do\)\do\,\do\?\do\'\do+\do\=\do\#}

%正文开始处：
\section{准备工作}
\subsection{需求分析}
设计一个模块的初始化框架。
\subsection{测试方法}
如何测试？

使用printk打印调试信息。

\section{模块init和exit函数}
今天的任务就是写出init和exit这两个最基本的函数。
\subsection{最简单的hello.c测试文件}
为了上手，先测试最简单的hello.c类型的文件。
\textcolor[rgb]{1.00,0.00,0.00}{zsl\_cache.c}文件内容如下：

\begin{lstlisting}
#include <linux/init.h>
#include <linux/module.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Zhao Shulin");
MODULE_DESCRIPTION("First step for my cache");

static int __init zsl_init(void)
{
    printk(KERN_ALERT "hello, zsl."\n);
    return 0;
}
static void __exit zsl_exit(void)
{
    printk(KERN_ALERT "goodbye, zsl."\n);
}

module_init(zsl_init);
module_exit(zsl_exit);
\end{lstlisting}

\textcolor[rgb]{1.00,0.00,0.00}{Makefile}文件内容如下：
\begin{lstlisting}
obj-m := zsl_cache.o
KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

default:
    $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
clean:
    $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) clean
    rm -rf Modules.markers module.order module.symvers
\end{lstlisting}

然后，编译命令如下：
\begin{enumerate}[(1)]
\item 执行\textcolor[rgb]{0.50,0.00,0.00}{sudo -i}命令：进入root权限；
\item 执行\textcolor[rgb]{0.50,0.00,0.00}{make}命令：生成zsl\_cache.ko文件；
\item 执行\textcolor[rgb]{0.50,0.00,0.00}{insmod ./zsl\_cache.ko}命令：加载模块；
\item 执行\textcolor[rgb]{0.50,0.00,0.00}{rmmod zsl\_cache} 命令：卸载模块。
\end{enumerate}

注意：执行insmod和rmmod命令之后，无法在终端输出打印信息，试图通过命令\textcolor[rgb]{0.00,0.00,1.00}{echo 8 $>$ /proc/sys/kernel/printk} 来降低控制台的loglevel，通过命令\textcolor[rgb]{0.25,0.00,0.50}{cat /proc/sys/kernel/printk}来查看是否完成。但是依然无法输出到控制台。Google之后，试图通过\textcolor[rgb]{0.00,1.00,1.00}{vi /etc/rsyslog.d/50-default.conf} 命令来编辑日志配置文件。通过命令\textcolor[rgb]{0.00,0.00,1.00}{who}来查看当前终端的pts号（假设是1）。然后在\textcolor[rgb]{0.00,1.00,1.00}{/etc/rsyslog.d/50-default.conf} 文件中讲\textcolor[rgb]{0.50,0.00,0.50}{kern.*        -/var/log/kern.log}一行修改为\textcolor[rgb]{0.50,0.00,0.50}{kern.*        -/dev/pts/1}，然后执行命令\textcolor[rgb]{0.00,1.00,0.25}{sudo service rsyslog restart}，即可在终端打印printk信息了。如果还不行，可以通过命令\textcolor[rgb]{1.00,0.00,0.00}{tail -n 10 /var/log/kern.log}来查看输出信息。

\emph{ps：Ubuntu Host与Ubuntu Guest共享文件夹：安装Virtual Box的增强功能之后，选择自动挂载，即可在/media下看到共享文件夹（以sf\_开头）。}

\subsection{实现基本的init}
\subsubsection{首先分配一块cache出来}
kmem\_cache\_create函数的Kernel API介绍如下：\url{http://oss.org.cn/ossdocs/gnu_linux/kernel-api/r3758.html}

简要总结如下：
\begin{itemize}
   \item 函数作用：创建slab缓存。
   \item 头文件：linux/slab.h
   \item 入参：\begin{itemize}
                         \item name：缓存名称，用于/proc/slabinfo 文件中唯一确认此缓存。如："my\_cache"
                         \item size：使用此cache的对象的大小。如：sizeof(struct my\_object)
                         \item align：对象对齐偏移量。如：\_\_ alignof\_\_struct my\_object)
                         \item flags：SLAB标志。一般为：0
                         \item ctor：对象析构函数，将在cache建立新页面时被调用，一般为：NULL
                         \end{itemize}
   \item 返回值：\begin{itemize}
                         \item 成功时：返回指向此cache的指针，一般的返回指针类型为struct kmem\_cache *
                         \item 失败时：返回NULL
                         \end{itemize}
   \end{itemize}
这样，可以很简单的使用此函数了。此时的\textcolor[rgb]{1.00,0.00,0.00}{zsl\_cache.c}文件内容如下：
\begin{lstlisting}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>

static struct kmem_cache *my_cache;
struct my_object{
	int should_add_later;
};

static int __init  zsl_init(void)
{
	printk(KERN_ALERT "hello, zsl.\n");
	my_cache = kmem_cache_create("my_cache",sizeof(struct my_object), __alignof__(struct my_object), 0, NULL );
	
	if(!my_cache){
		printk(KERN_EMERG "error: kmem_cache_create failed!\n");
		return -1;
	}
	printk(KERN_ALERT "kmem_cache_create succeed!\n");
	return 0;

}

static void __exit zsl_exit(void)
{
	printk(KERN_ALERT "goodbye, zsl.\n");
}

module_init(zsl_init);
module_exit(zsl_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Zhao Shulin");
MODULE_DESCRIPTION("Stay Focus!");
\end{lstlisting}
验证通过！

\subsubsection{然后分配一个内存池}
上一小节分配了一块cache，接着这个活，我们为了确保内存的成功分配，所以准备接着创建一个内存池。mempool\_create 函数的Kernel API介绍如下：\url{https://www.kernel.org/doc/htmldocs/kernel-api/API-mempool-create.html}

简要总结如下：
\begin{itemize}
   \item 函数作用：创建一个内存池。
   \item 头文件：linux/mempool.h
   \item 入参：\begin{itemize}
                         \item min\_nr：为内存池分配的最小内存成员数量。如：1024
                         \item alloc\_fn：内存分配函数。如：mempool.h文件中定义的mempool\_alloc\_slab函数
                         \item free\_fn：内存释放函数。如：mempool.h 文件中定义的mempool\_free\_slab函数
                         \item pool\_data：要管理的cache指针，本例中即为上一小节中的：my\_cache
                         \end{itemize}
   \item 返回值：\begin{itemize}
                         \item 成功时：返回指向此pool的指针，一般的返回指针类型为 mempool.h文件中定义的struct mempool\_s *
                         \item 失败时：返回NULL
                         \end{itemize}
   \end{itemize}
这样，可以很简单的使用此函数了。此时的\textcolor[rgb]{1.00,0.00,0.00}{zsl\_cache.c}文件内容如下：
\begin{lstlisting}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/mempool.h>

static struct kmem_cache *my_cache;
struct my_object{
	int should_add_later;
};
static mempool_t *my_pool;

static int __init  zsl_init(void)
{
	printk(KERN_ALERT "hello, zsl.\n");
	my_cache = kmem_cache_create("my_cache",sizeof(struct my_object), __alignof__(struct my_object), 0, NULL );
	
	if(!my_cache){
		printk(KERN_EMERG "error: kmem_cache_create failed!\n");
		return -1;
	}
	printk(KERN_ALERT "kmem_cache_create succeed!\n");

	my_pool = mempool_create(1024, mempool_alloc_slab, mempool_free_slab, my_cache);
	if(!my_pool){
		printk(KERN_EMERG "error: mempool_create failed!\n");
		kmem_cache_destroy(my_cache);
		return -2;
	}	
	
	printk(KERN_ALERT "mempool_create succeed!\n");

	return 0;

}

static void __exit zsl_exit(void)
{
	printk(KERN_ALERT "goodbye, zsl.\n");
}

module_init(zsl_init);
module_exit(zsl_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Zhao Shulin");
MODULE_DESCRIPTION("Stay Focus!");

\end{lstlisting}
验证通过！

\subsubsection{创建一个工作队列}
因为工作队列的优势在于可以允许重新调度、睡眠，所以我们要初始化一个工作队列。工作队列（workqueue）可以将工作\textcolor[rgb]{1.00,0.00,0.00}{推后执行}，即所谓的“\textcolor[rgb]{0.00,0.00,1.00}{下半部分}”。create\_singlethread\_workqueue 函数的Kernel API介绍如下：\url{http://lwn.net/Articles/81119/}

简要总结如下：
\begin{itemize}
   \item 函数作用：创建一个工作队列。
   \item 头文件：linux/workqueue.h
   \item 入参：name：描述此工作队列的字符串，比如："my\_workqueue"
   \item 返回值：\begin{itemize}
                         \item 成功时：返回指向此workqueue 的指针，一般的返回指针类型为 workqueue.h 文件中定义的struct workqueue\_struct *
                         \item 失败时：返回NULL
                         \end{itemize}
   \end{itemize}
这样，可以很简单的使用此函数了。此时的\textcolor[rgb]{1.00,0.00,0.00}{zsl\_cache.c}文件内容如下：
\begin{lstlisting}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/mempool.h>
#include <linux/workqueue.h>

static struct workqueue_struct *my_workqueue;
static struct kmem_cache *my_cache;
struct my_object{
	int should_add_later;
};
static mempool_t *my_pool;

static int __init  zsl_init(void)
{
	printk(KERN_ALERT "hello, zsl.\n");
	my_cache = kmem_cache_create("my_cache",sizeof(struct my_object), __alignof__(struct my_object), 0, NULL );
	
	if(!my_cache){
		printk(KERN_EMERG "error: kmem_cache_create failed!\n");
		return -1;
	}
	printk(KERN_ALERT "kmem_cache_create succeed!\n");

	my_pool = mempool_create(1024, mempool_alloc_slab, mempool_free_slab, my_cache);
	if(!my_pool){
		printk(KERN_EMERG "error: mempool_create failed!\n");
		kmem_cache_destroy(my_cache);
		return -2;
	}	
		printk(KERN_ALERT "mempool_create succeed!\n");

	my_workqueue = create_singlethread_workqueue("zsl_kcache");
	if(!my_workqueue){
		printk(KERN_EMERG "error: create_singlethread_workqueue failed!\n");
		return -3;
	}

	printk(KERN_ALERT "create_singlethread_workqueue succeed!\n");

	return 0;

}

static void __exit zsl_exit(void)
{
	printk(KERN_ALERT "goodbye, zsl.\n");
}

module_init(zsl_init);
module_exit(zsl_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Zhao Shulin");
MODULE_DESCRIPTION("Stay Focus!");

\end{lstlisting}
验证通过！

\subsubsection{新建一个工作work}
INIT\_WORK(\_work, \_func)可以新建一个work，该work在创建好之后，一般可以通过queue\_work(workqueue, \&work)函数来把该work放到上一小节中创建的workqueue中工作（即运行自定义的\_func函数）。

INIT\_WORK(\_work, \_func)简要总结如下：
\begin{itemize}
   \item 函数作用：创建一个工作。
   \item 头文件：linux/workqueue.h
   \item 入参：\begin{itemize}
                         \item \_work：该工作的名称，一般为workqueue.h中定义的struct work\_struct *
                         \item \_func： 用户自定义的函数
                         \end{itemize}
   \item 返回值：无
   \end{itemize}
此时的\textcolor[rgb]{1.00,0.00,0.00}{zsl\_cache.c}文件内容如下：
\begin{lstlisting}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/mempool.h>
#include <linux/workqueue.h>

static struct work_struct my_work;
static struct workqueue_struct *my_workqueue;
static struct kmem_cache *my_cache;
struct my_object{
	int should_add_later;
};
static mempool_t *my_pool;

static void do_work()
{
	printk(KERN_ALERT "This is do_work!\n");	
}

static int __init  zsl_init(void)
{
	printk(KERN_ALERT "hello, zsl.\n");
	my_cache = kmem_cache_create("my_cache",sizeof(struct my_object), __alignof__(struct my_object), 0, NULL );
	
	if(!my_cache){
		printk(KERN_EMERG "error: kmem_cache_create failed!\n");
		return -1;
	}
	printk(KERN_ALERT "kmem_cache_create succeed!\n");

	my_pool = mempool_create(1024, mempool_alloc_slab, mempool_free_slab, my_cache);
	if(!my_pool){
		printk(KERN_EMERG "error: mempool_create failed!\n");
		kmem_cache_destroy(my_cache);
		return -2;
	}	
		printk(KERN_ALERT "mempool_create succeed!\n");

	my_workqueue = create_singlethread_workqueue("zsl_kcache");
	if(!my_workqueue){
		printk(KERN_EMERG "error: create_singlethread_workqueue failed!\n");
		return -3;
	}

	printk(KERN_ALERT "create_singlethread_workqueue succeed!\n");

	INIT_WORK(&my_work, do_work);
	return 0;

}

static void __exit zsl_exit(void)
{
	printk(KERN_ALERT "goodbye, zsl.\n");
}

module_init(zsl_init);
module_exit(zsl_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Zhao Shulin");
MODULE_DESCRIPTION("Stay Focus!");

\end{lstlisting}
验证成功。

至此，最基本的init已经完成。下一节会实现device mapper。

\subsection{添加device mapper}
\subsubsection{Device Mapper 的基础知识}
假如一台主机插入了多块硬盘，单块硬盘的容量和性能都是有限的，如果能将多块硬盘组合一个逻辑的整体，对于这台主机来讲，就实现了最简单意义上的“云存储”。所以，Linux内核中出现了Device Mapper。简单来讲，Device Mapper是一种组合多个块设备变成一个逻辑块设备的机制。

Device Mapper的设计实现主要分为三层，如图\ref{fig1}所示：
\begin{figure}[htbp]
\centering
\scalebox{0.6}{\includegraphics{1.eps}}
\caption{Device Mapper的设计实现。}
\label{fig1}
\end{figure}

\begin{itemize}
   \item Mapped Device：映射之后的逻辑设备，对应于内核中的\textcolor[rgb]{1.00,0.00,0.00}{struct mapped\_device}
   \item Mapping Table：映射规则表，对应于内核中的\textcolor[rgb]{1.00,0.00,0.00}{struct dm\_table}
   \item Target Device：底层的实际设备（\textcolor[rgb]{0.00,0.00,1.00}{注：既可以是物理设备，也可以是低一层的Device Mapper映射出的逻辑设备。}），对应于内核中的\textcolor[rgb]{1.00,0.00,0.00}{struct dm\_target}
\end{itemize}
再看两个内核里面的两个重要内容：
\begin{itemize}
   \item struct \textcolor[rgb]{0.00,0.00,0.63}{target\_type}：自定义一种target type的类型
    \item \textcolor[rgb]{0.00,0.00,0.63}{dm\_register\_target}：此函数使用上面自定义的结构体注册一个新的target type
\end{itemize}
注意：上述内容需要头文件linux/device-mapper.h。

此时的\textcolor[rgb]{1.00,0.00,0.00}{zsl\_cache.c}文件内容如下：
\begin{lstlisting}
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/mempool.h>
#include <linux/workqueue.h>
#include <linux/device-mapper.h>

static struct work_struct my_work;
static struct workqueue_struct *my_workqueue;
static struct kmem_cache *my_cache;
struct my_object{
	int should_add_later;
};
static mempool_t *my_pool;
static struct target_type my_cache_target = {
	.name = "my_cache",
	.version = {0,0,0},
	.module = THIS_MODULE,
	.ctr = NULL,
	.dtr = NULL,
// should add something later...

};

static void do_work(void)
{
	printk(KERN_ALERT "This is do_work!\n");	
}

static int __init  zsl_init(void)
{
	printk(KERN_ALERT "hello, zsl.\n");
	my_cache = kmem_cache_create("my_cache",sizeof(struct my_object), __alignof__(struct my_object), 0, NULL );
	
	if(!my_cache){
		printk(KERN_EMERG "error: kmem_cache_create failed!\n");
		return -1;
	}
	printk(KERN_ALERT "kmem_cache_create succeed!\n");

	my_pool = mempool_create(1024, mempool_alloc_slab, mempool_free_slab, my_cache);
	if(!my_pool){
		printk(KERN_EMERG "error: mempool_create failed!\n");
		kmem_cache_destroy(my_cache);
		return -2;
	}	
		printk(KERN_ALERT "mempool_create succeed!\n");

	my_workqueue = create_singlethread_workqueue("zsl_kcache");
	if(!my_workqueue){
		printk(KERN_EMERG "error: create_singlethread_workqueue failed!\n");
		return -3;
	}

	printk(KERN_ALERT "create_singlethread_workqueue succeed!\n");

	INIT_WORK(&my_work, do_work);

	if(dm_register_target(&my_cache_target)<0)
		{
			printk(KERN_EMERG "error: dm_register_target failed!\n");
			return -4;
		}
	else
		printk(KERN_ALERT "dm_register_target succeed!\n");

	return 0;

}

static void __exit zsl_exit(void)
{
	dm_unregister_target(&my_cache_target);
	printk(KERN_ALERT "dm_unregister_target succeed!\n");

	mempool_destroy(my_pool);
	printk(KERN_ALERT "mempool_destroy succeed!\n");
	
	kmem_cache_destroy(my_cache);
	printk(KERN_ALERT "kmem_cache_destroy succeed!\n");
		
	my_pool = NULL;
	my_cache = NULL;

	destroy_workqueue(my_workqueue);
	printk(KERN_ALERT "destroy_workqueue succeed!\n");

	
	printk(KERN_ALERT "goodbye, zsl.\n");
}

module_init(zsl_init);
module_exit(zsl_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Zhao Shulin");
MODULE_DESCRIPTION("Stay Focus!");

\end{lstlisting}
验证成功。

至此，init和exit框架已经搭建完毕了。


























\end{CJK*}
\end{document}
